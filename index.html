<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Playing Assistant (with Wild Card Rank)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <h1>Rummy Playing Assistant (with Wild Card)</h1>
  <p>
    Enter the <strong>ranks</strong> you have for each suit (comma‐separated), choose your <strong>wild card rank</strong>, and specify how many pure Jokers (<strong>JOK</strong>) you have (0–2).  
    A “wild card rank” (e.g. 7) means that any 7 of any suit can act either as a normal “7” in a pure run of its suit, or as a wildcard in an impure sequence.  
    Example:
    <ul>
      <li>Clubs (♣): <em>A,2,3,8</em></li>
      <li>Diamonds (♦): <em>4,5,6,Q</em></li>
      <li>Hearts (♥): <em>7,9,K</em></li>
      <li>Spades (♠): <em>A,8,J</em></li>
      <li>Wild Card Rank: <em>8</em> (so any “8♣, 8♦, 8♥, 8♠” can be used as wildcard)
      <li>Number of Jokers: <em>1</em> (so you have one “JOK” card from the deck)
    </ul>
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. A,2,3,8" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 4,5,6,Q" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 7,9,K" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. A,8,J" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ---- Utility Functions ----

    // Map face-card ranks to numeric values
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
      // Note: Jokers (JOK) and wild-card ranks handled separately
    };

    // Extract the rank portion from a card string (e.g. "10♠" → "10", "JOK" → null)
    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    // Extract suit from card (e.g. "10♠" → "♠")
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    // Count a single card’s points:
    //   • A,10,J,Q,K = 10 points each  
    //   • Numbered cards (2–9) = face value  
    //   • Jokers (JOK) = 0 points  
    //   • Wild-card‐rank cards: If not used in any sequence, count them as their face value (10 for A/10/J/Q/K; numeric otherwise)
    function cardPointValue(card) {
      if (card === 'JOK') return 0;
      const rank = getRank(card);
      if (['A','10','J','Q','K'].includes(rank)) return 10;
      return parseInt(rank, 10);
    }

    // ---- Sequence-Finding Logic ----

    /**
     * findPureSequence(allCards):
     *   Finds the longest “pure” (no wilds/jokers) run of length ≥ 3 in any one suit.
     *   Returns an array of card‐strings that make up that pure sequence. If none ≥ 3, returns [].
     */
    function findPureSequence(allCards) {
      let bestRun = [];
      const suitOrder = ['♣','♦','♥','♠'];

      suitOrder.forEach(suit => {
        // Collect all NON-joker, NON-wildcard cards of this suit
        const suitList = allCards
          .filter(c => typeof c === 'string' && c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined);

        if (suitList.length < 3) return;

        // Sort by numeric rank
        suitList.sort((a, b) => a.num - b.num);
        const nums = suitList.map(o => o.num);

        // Scan for the longest run of consecutive numbers
        let i = 0;
        while (i < nums.length) {
          let run = [ suitList[i] ];
          let prev = nums[i];
          let j = i + 1;
          while (j < nums.length && nums[j] === prev + 1) {
            run.push(suitList[j]);
            prev = nums[j];
            j++;
          }
          if (run.length >= 3 && run.length > bestRun.length) {
            bestRun = run.map(o => o.card);
          }
          i++;
        }
      });

      return bestRun;
    }

    /**
     * findImpureSequence(allCards, designatedRank):
     *   Finds the best impure sequence (length ≥ 3) in any suit, allowing:
     *     • “Pure” Jokers ("JOK"), and
     *     • Any card whose rank == designatedRank (i.e. wild‐card rank), 
     *       which can be used AS a wildcard or AS its face value if it matches a suit/run.
     *   Returns an array of card‐strings making up that sequence (present cards + used wildcards).
     *   If none ≥ 3, returns [].
     */
    function findImpureSequence(allCards, designatedRank) {
      // Count pure Jokers
      const pureJokers = allCards.filter(c => c === 'JOK').length;
      // Collect all designated‐rank cards (regardless of suit)
      const designatedCards = allCards.filter(c => 
        typeof c === 'string' && getRank(c) === designatedRank
      );
      const wildcardCount = pureJokers + designatedCards.length;

      // Non-joker, non-designated cards:
      const nonWildCards = allCards.filter(c => 
        c !== 'JOK' && getRank(c) !== designatedRank
      );

      let bestRun = [];
      const suitOrder = ['♣','♦','♥','♠'];

      suitOrder.forEach(suit => {
        // Build a map: rank → cardString for all cards of this suit that are NOT designated‐rank
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (typeof c === 'string' && getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a,b) => a - b);
        if (ranks.length === 0 && wildcardCount < 3) return;

        // Maximum possible length of a sequence in this suit = ranks.length + wildcardCount
        // Try window sizes from that maximum down to 3:
        const maxPossibleLen = ranks.length + wildcardCount;
        for (let windowSize = maxPossibleLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCount = 0;
            const presentCards = [];

            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }

            // Number of missing cards = windowSize - presentCount
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              // We can fill those gaps with Jokers or designated cards acting as wildcard
              const runCards = presentCards.slice();
              // Pull missing wildcards from either pureJokers first or designatedCards
              let toUse = missing;
              // Use pure Jokers (string "JOK") first
              for (let k = 0; k < pureJokers && toUse > 0; k++) {
                runCards.push('JOK');
                toUse--;
              }
              // Then use designated cards
              for (let k = 0; k < designatedCards.length && toUse > 0; k++) {
                runCards.push(designatedCards[k]);
                toUse--;
              }
              if (runCards.length > bestRun.length) {
                bestRun = runCards;
              }
              // Once found a run for this windowSize, no need to try smaller windows
              return;
            }
          }
        }
      });

      return bestRun;
    }

    /**
     * evaluateHand(allCards, designatedRank):
     *   1) Find best pure sequence (no wild/ jokers).
     *   2) Remove those cards, then find best impure sequence (using wildcards).
     *   3) Leftover cards = everything not in either sequence.
     *   4) Sum points of leftover (A/10/J/Q/K=10; numeric=face; JOK=0). Cap at 80.
     */
    function evaluateHand(allCards, designatedRank) {
      // 1) Pure sequence
      const pureRun = findPureSequence(allCards);
      if (pureRun.length < 3) {
        // No pure sequence → all cards count
        let total = allCards.reduce((sum, c) => sum + cardPointValue(c), 0);
        if (total > 80) total = 80;
        return {
          pureSequence: [],
          impureSequence: [],
          leftover: allCards.slice(),
          points: total
        };
      }

      // Remove pureRun from a copy of allCards
      let remaining = allCards.slice();
      pureRun.forEach(card => {
        const idx = remaining.indexOf(card);
        if (idx !== -1) remaining.splice(idx, 1);
      });

      // 2) Impure sequence
      const impureRun = findImpureSequence(remaining.slice(), designatedRank);
      let leftover;
      if (impureRun.length < 3) {
        // No impure sequence → everything not in pureRun counts
        leftover = remaining.slice();
      } else {
        // Remove impureRun from remaining
        leftover = remaining.slice();
        impureRun.forEach(card => {
          const idx = leftover.indexOf(card);
          if (idx !== -1) leftover.splice(idx, 1);
        });
      }

      // 3) Sum points of leftover
      let total = leftover.reduce((sum, c) => sum + cardPointValue(c), 0);
      if (total > 80) total = 80;

      return {
        pureSequence: pureRun,
        impureSequence: impureRun,
        leftover: leftover,
        points: total
      };
    }


    // ---- DOM & Event Handlers ----

    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = '';  // Clear previous results

      // Helper: parse one suit’s text into array of "<rank><suit>" strings
      function parseSuit(text, suitSymbol) {
        if (!text.trim()) return [];
        return text
          .split(',')
          .map(s => s.trim().toUpperCase())
          .filter(s => s.length > 0)
          .map(s => s + suitSymbol);
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;       // e.g. "8" or "" for none
      const jokersRaw   = jokersInput.value.trim();    // e.g. "1" or "0"

      // 2) Validate number of Jokers
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build full card array
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      // Add that many "JOK" cards
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Validate each card’s format
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const rank = getRank(c);
        const suit = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(rank) || !validSuits.includes(suit)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML = 
          '<span class="error">Invalid card(s): ' +
          invalids.join(', ') +
          '.<br>Use ranks A,2–10,J,Q,K per suit input, and specify Jokers separately.</span>';
        return;
      }

      // 5) If no wildRank selected, set to null
      const designatedRank = wildRank || null;

      // 6) Evaluate
      const evalResult = evaluateHand(cards, designatedRank);

      // 7) Display output
      let html = '';
      html += '<strong>Pure sequence found:</strong> ' +
              (evalResult.pureSequence.length ? evalResult.pureSequence.join(', ') : 'None') + '<br>';
      html += '<strong>Impure sequence found:</strong> ' +
              (evalResult.impureSequence.length ? evalResult.impureSequence.join(', ') : 'None') + '<br>';
      html += '<strong>Leftover cards (counted as points):</strong> ' +
              (evalResult.leftover.length ? evalResult.leftover.join(', ') : 'None') + '<br>';
      html += '<strong>Total points (capped at 80):</strong> ' + evalResult.points;

      resultDiv.innerHTML = html;
    });

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
