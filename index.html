<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Assistant (Two Decks Support)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
      white-space: pre-wrap;
    }
    .error {
      color: red;
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Rummy Assistant (Two Decks Support)</h1>
  <p>
    Enter exactly 13 cards total. For each suit (♣, ♦, ♥, ♠), type your ranks as a <strong>continuous string</strong> (no commas/spaces), using:
    <br>
    <strong>`A 2 3 4 5 6 7 8 9 T J Q K`</strong> 
    (where **T** = “10”). Then choose your Wild‐card rank (or leave blank), and specify how many pure Jokers (JOK) you have (0–2).
    <br><br>
    <strong>Note on Two Decks:</strong> You may see the same rank‐suit twice (e.g. two “8♣”). For forming any set, those two identical 8♣ cannot both count. In other words, a set of three “8”s must come from three “different suits”—duplicates of the same suit do not count twice. Everything else (pure sequences, impure sequences, leftover points) follows the same rules as before.
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. 89T3" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 57" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 35689" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. 35" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ----------------------------
    // UTILITY & EVALUATION LOGIC
    // ----------------------------
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
    };

    // Convert “T” → “10”, else return the character
    function normalizeRankChar(ch) {
      if (ch === 'T') return '10';
      return ch;
    }

    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    // Point value: JOK = 0, wild = 0, A/10/J/Q/K = 10, others face value
    function cardPointValue(card, designatedWild) {
      if (card === 'JOK') return 0;
      const r = getRank(card);
      if (r === designatedWild) return 0;
      if (['A','10','J','Q','K'].includes(r)) return 10;
      return parseInt(r, 10);
    }

    // 1) Find pure sequences (length ≥ 3) in a given suit.
    //    Pass 1 (Normal‐only): exclude JOK & rank = designatedWild.
    //    Pass 2 (Fallback): exclude only JOK (include wild).
    function findPureSequencesForSuit(cards, suit, designatedWild) {
      // Pass 1: “Normal-only”
      const normalList = cards
        .filter(c => c !== 'JOK' && getSuit(c) === suit && getRank(c) !== designatedWild)
        .map(c => ({ card: c, num: rankMap[getRank(c)] }))
        .filter(o => o.num !== undefined)
        .sort((a, b) => a.num - b.num);

      const sequences = [];
      const nums = normalList.map(o => o.num);
      let i = 0;
      while (i < nums.length) {
        let run = [normalList[i]];
        let prev = nums[i];
        let j = i + 1;
        while (j < nums.length && nums[j] === prev + 1) {
          run.push(normalList[j]);
          prev = nums[j];
          j++;
        }
        if (run.length >= 3) {
          sequences.push(run.map(o => o.card));
          i = j;
        } else {
          i++;
        }
      }

      // Pass 2: fallback (only if no run found above)
      if (sequences.length === 0) {
        const allList = cards
          .filter(c => c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined)
          .sort((a, b) => a.num - b.num);

        const allNums = allList.map(o => o.num);
        let x = 0;
        while (x < allNums.length) {
          let run = [allList[x]];
          let prev = allNums[x];
          let y = x + 1;
          while (y < allNums.length && allNums[y] === prev + 1) {
            run.push(allList[y]);
            prev = allNums[y];
            y++;
          }
          if (run.length >= 3) {
            sequences.push(run.map(o => o.card));
            x = y;
          } else {
            x++;
          }
        }
      }

      return sequences; // array of [card,...]
    }

    function findAllPureSequences(cards, designatedWild) {
      const out = [];
      for (const s of ['♣','♦','♥','♠']) {
        const seqs = findPureSequencesForSuit(cards, s, designatedWild);
        out.push(...seqs);
      }
      return out;
    }

    // 2) Find all pure sets (≥ 3 cards of same rank, distinct suits).
    function findAllPureSets(cards) {
      const buckets = {};
      // Group cards by rank → map of suit→list-of-duplicates
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        if (!buckets[r]) buckets[r] = {};
        const s = getSuit(c);
        if (!buckets[r][s]) buckets[r][s] = [];
        buckets[r][s].push(c);
      });

      const sets = [];
      for (const r in buckets) {
        // suitsMap = { suit: [ “<rank><suit>” … ] }
        const suitsMap = buckets[r];
        const distinctSuits = Object.keys(suitsMap);
        if (distinctSuits.length >= 3) {
          // Build every combination of 3 distinct suits
          for (let a = 0; a < distinctSuits.length - 2; a++) {
            for (let b = a + 1; b < distinctSuits.length - 1; b++) {
              for (let c = b + 1; c < distinctSuits.length; c++) {
                const suitA = distinctSuits[a];
                const suitB = distinctSuits[b];
                const suitC = distinctSuits[c];
                // From each suit’s array of duplicates, pick exactly one card
                const cardA = suitsMap[suitA][0];
                const cardB = suitsMap[suitB][0];
                const cardC = suitsMap[suitC][0];
                sets.push([cardA, cardB, cardC]);
              }
            }
          }
        }
      }
      return sets; // array of [card,card,card]
    }

    // 3) Enumerate all impure sequences (length ≥ 3).
    function findAllImpureSequences(cards, designatedWild) {
      const impureSeqs = [];
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const designatedCards = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      const wildcardCount = pureJokers + designatedCards.length;
      const nonWildCards = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);

      for (const suit of ['♣','♦','♥','♠']) {
        // Build map rankNumber → card (one per rank; duplicates of same rank& suit are redundant in sequence)
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a, b) => a - b);
        const maxLen = ranks.length + wildcardCount;

        for (let windowSize = maxLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCards = [];
            let presentCount = 0;
            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              let usedJ = 0, usedD = 0;
              const runCards = presentCards.slice();
              for (let k = 0; k < missing; k++) {
                if (usedJ < pureJokers) {
                  runCards.push('JOK');
                  usedJ++;
                } else {
                  runCards.push(designatedCards[usedD]);
                  usedD++;
                }
              }
              // Sort runCards by rank (JOK at the end)
              runCards.sort((a, b) => {
                if (a === 'JOK') return 1;
                if (b === 'JOK') return -1;
                const na = rankMap[getRank(a)], nb = rankMap[getRank(b)];
                return na - nb;
              });
              const key = JSON.stringify(runCards);
              if (!impureSeqs.some(existing => JSON.stringify(existing) === key)) {
                impureSeqs.push(runCards);
              }
            }
          }
        }
      }
      return impureSeqs; // array of [card, …]
    }

    // 4) Enumerate all impure sets (exactly 3 cards of same rank, distinct suits + wildcards).
    function findAllImpureSets(cards, designatedWild) {
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const wildcardsList = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      // Group actual cards by rank → suit → list of duplicates
      const buckets = {};
      cards.forEach(c => {
        if (c === 'JOK' || getRank(c) === designatedWild) return;
        const r = getRank(c), s = getSuit(c);
        if (!buckets[r]) buckets[r] = {};
        if (!buckets[r][s]) buckets[r][s] = [];
        buckets[r][s].push(c);
      });

      const sets = [];
      for (const r in buckets) {
        const suitsMap = buckets[r];
        const distinctSuits = Object.keys(suitsMap);
        const suitCount = distinctSuits.length;
        const totalWildcards = pureJokers + wildcardsList.length;

        if (suitCount + totalWildcards < 3) continue;

        // We need exactly 3 cards. Let m = # of actual distinct suits used (0 <= m <= 3).
        // m cannot exceed suitCount, and (3 - m) cannot exceed totalWildcards.
        for (let m = Math.min(3, suitCount); m >= Math.max(0, 3 - totalWildcards); m--) {
          // Choose m distinct suits out of distinctSuits
          function choose(arr, k) {
            const result = [];
            function helper(start, combo) {
              if (combo.length === k) {
                result.push(combo.slice());
                return;
              }
              for (let i = start; i < arr.length; i++) {
                combo.push(arr[i]);
                helper(i + 1, combo);
                combo.pop();
              }
            }
            helper(0, []);
            return result;
          }
          const suitCombos = choose(distinctSuits, m);
          suitCombos.forEach(suitsChosen => {
            // For each chosen suit, pick exactly one card instance (if duplicates exist, pick the first).
            const actualCards = suitsChosen.map(s => suitsMap[s][0]);
            const missing = 3 - m;
            const chosenJOKs = [];
            let usedJ = Math.min(missing, pureJokers);
            for (let i = 0; i < usedJ; i++) chosenJOKs.push('JOK');
            let wdUsed = missing - usedJ;
            for (let i = 0; i < wdUsed; i++) chosenJOKs.push(wildcardsList[i]);
            const setGrp = actualCards.concat(chosenJOKs);
            sets.push(setGrp);
          });
        }
      }
      return sets; // array of [card,card,card]
    }

    // Helper: remove one occurrence of each element in rem from src
    function arrayMinus(src, rem) {
      const out = src.slice();
      rem.forEach(el => {
        const idx = out.indexOf(el);
        if (idx !== -1) out.splice(idx, 1);
      });
      return out;
    }

    // 5) Recursively search impure groups (with exhaustive enumeration).
    function searchImpureGroups(working, designatedWild, sequencesFormedCount) {
      // If we still need two sequences total (pure + impure), force an impure sequence first if possible
      if (sequencesFormedCount < 2) {
        const allSeqs = findAllImpureSequences(working, designatedWild);
        if (allSeqs.length > 0) {
          let bestBranch = null;
          allSeqs.forEach(seq => {
            const remSeq = arrayMinus(working, seq);
            const sub = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
            const branch = {
              impureSets: sub.impureSets.slice(),
              impureSeqs: [seq, ...sub.impureSeqs],
              leftover: sub.leftover.slice(),
              points: sub.points
            };
            if (!bestBranch || branch.points < bestBranch.points) {
              bestBranch = branch;
            }
          });
          return bestBranch;
        }
        // If no impure sequence exists, fall through to consider sets (still < 2).
      }

      // Now (sequencesFormedCount ≥ 2) OR (no sequence found when < 2).
      // We enumerate both impure sequences & impure sets, then compare. If none exist, leftover only.
      let bestOutcome = null;

      // (A) Try all impure sequences
      const allSeqs2 = findAllImpureSequences(working, designatedWild);
      allSeqs2.forEach(seq => {
        const remSeq = arrayMinus(working, seq);
        const subSeq = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
        const candidate = {
          impureSets: subSeq.impureSets.slice(),
          impureSeqs: [seq, ...subSeq.impureSeqs],
          leftover: subSeq.leftover.slice(),
          points: subSeq.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B) Try all impure sets
      const allSets = findAllImpureSets(working, designatedWild);
      allSets.forEach(setGrp => {
        const remSet = arrayMinus(working, setGrp);
        const subSet = searchImpureGroups(remSet, designatedWild, sequencesFormedCount);
        const candidate = {
          impureSets: [setGrp, ...subSet.impureSets],
          impureSeqs: subSet.impureSeqs.slice(),
          leftover: subSet.leftover.slice(),
          points: subSet.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (C) If neither sequences nor sets possible → leftover only
      if (!bestOutcome) {
        const leftoverOnly = working.filter(c => c !== 'JOK');
        let ptsOnly = leftoverOnly.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (ptsOnly > 80) ptsOnly = 80;
        bestOutcome = {
          impureSets: [],
          impureSeqs: [],
          leftover: leftoverOnly,
          points: ptsOnly
        };
      }

      return bestOutcome;
    }

    // 6) Recursively search pure groups; once no more pure groups, hand off to impure.
    function searchPureGroups(working, designatedWild) {
      const pureSeqs = findAllPureSequences(working, designatedWild);
      const pureSets = findAllPureSets(working);

      // If no pure groups at all, jump to impure with 0 sequences formed
      if (pureSeqs.length === 0 && pureSets.length === 0) {
        const imp = searchImpureGroups(working, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }

      let bestOutcome = null;

      // (A) Try each pure sequence (counts as 1 sequence formed)
      pureSeqs.forEach(seq => {
        const rem = arrayMinus(working, seq);
        const sub = searchImpureGroups(rem, designatedWild, 1);
        const candidate = {
          pureSeqs: [seq],
          pureSets: [],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B) Try each pure set (does NOT increase sequence count)
      pureSets.forEach(setGrp => {
        const rem = arrayMinus(working, setGrp);
        const sub = searchPureGroups(rem, designatedWild);
        const candidate = {
          pureSeqs: sub.pureSeqs.slice(),
          pureSets: [setGrp, ...sub.pureSets],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (C) Skip pure entirely → go to impure with 0 sequences formed
      {
        const imp = searchImpureGroups(working, designatedWild, 0);
        const candidate = {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      }

      return bestOutcome;
    }

    // 7) Main evaluation. If no pure sequences exist, do impure with 0; else recurse.
    function evaluateHand(cards, designatedWild) {
      const allPureSeqs = findAllPureSequences(cards, designatedWild);
      if (allPureSeqs.length === 0) {
        const imp = searchImpureGroups(cards, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }
      return searchPureGroups(cards, designatedWild);
    }

    // 8) If fewer than two sequences total (pure + impure), count all non‐JOK as leftover.
    function finalResult(cards, designatedWild) {
      const res = evaluateHand(cards, designatedWild);
      const totalSequences = res.pureSeqs.length + res.impureSeqs.length;
      if (totalSequences < 2) {
        const leftoverAll = cards.filter(c => c !== 'JOK');
        let pts = leftoverAll.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (pts > 80) pts = 80;
        return {
          pureSeqs: [], pureSets: [], impureSets: [], impureSeqs: [],
          leftover: leftoverAll,
          points: pts
        };
      }
      return res;
    }

    // ----------------------------
    // DOM & EVENT HANDLING
    // ----------------------------
    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = '';

      // Parse a continuous string (e.g. "89T3") into [ "<rank><suit>" ]
      function parseSuit(inputText, suitSymbol) {
        const chars = inputText.trim().toUpperCase().split('');
        const cards = [];
        chars.forEach(ch => {
          const norm = normalizeRankChar(ch);
          const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
          if (validRanks.includes(norm)) {
            cards.push(norm + suitSymbol);
          }
        });
        return cards;
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;   // "" or e.g. "J"
      const jokersRaw   = jokersInput.value.trim();

      // 2) Validate Jokers count
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build card array (suits + JOK)
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Enforce exactly 13 cards
      if (cards.length !== 13) {
        resultDiv.innerHTML = '<span class="error">Error: You must enter exactly 13 cards total (suits + Jokers). Currently you have ' 
                              + cards.length + '.</span>';
        return;
      }

      // 5) Validate each card’s format
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        const s = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(r) || !validSuits.includes(s)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML =
          '<span class="error">Invalid card(s): ' + invalids.join(', ') +
          '.<br>Use ranks A,2–9,T,J,Q,K plus suits ♣,♦,♥,♠.</span>';
        return;
      }

      // 6) Set designatedWild (or null)
      const designatedWild = wildRank || null;

      // 7) Compute final grouping & leftover
      const res = finalResult(cards, designatedWild);

      // 8) Build and display output
      let out = '';
      out += '<div class="section-title">All Pure Sequences (length ≥ 3):</div>';
      if (res.pureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.pureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Pure Sets (length ≥ 3):</div>';
      if (res.pureSets.length === 0) {
        out += '  None \n';
      } else {
        res.pureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sets (length ≥ 3, using wild/JOK):</div>';
      if (res.impureSets.length === 0) {
        out += '  None \n';
      } else {
        res.impureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sequences (length ≥ 3):</div>';
      if (res.impureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.impureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">Leftover Cards (counted as points):</div>';
      if (res.leftover.length === 0) {
        out += '  None \n';
      } else {
        out += '  ' + res.leftover.join(', ') + '\n';
      }

      out += '\n<div class="section-title">Total Points (capped at 80):</div>';
      out += '  ' + res.points + '\n';

      resultDiv.innerHTML = out;
    });

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
