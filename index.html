<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Assistant (Exclude Wild‐Rank from Leftovers)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
      white-space: pre-wrap;
    }
    .error {
      color: red;
    }
    ul {
      margin: 0 0 10px 20px;
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Rummy Assistant (Exclude Wild‐Rank from Leftovers)</h1>
  <p>
    Enter your cards by suit, choose the <strong>wild card rank</strong>, and specify how many pure Jokers (<strong>JOK</strong>) you possess (0–2).  
    Any card whose rank matches the chosen wild‐rank will be treated as “grouped” (and thus never count as leftover), and pure Jokers always count as zero.  
    The program will:
    <ol>
      <li>List <strong>all pure sequences</strong> (length ≥ 3) and remove them.</li>
      <li>Then repeatedly find the <strong>optimal impure sequence</strong> (length ≥ 3) that minimizes leftover‐point total, removing each.</li>
      <li>Any remaining cards whose rank ≠ wild‐rank will be shown as “leftover” (and counted); wild‐rank cards that were never used in a sequence are automatically removed from leftovers (0 points).</li>
      <li>Points for leftover: A/10/J/Q/K=10, 2–9=face value, capped at 80.</li>
    </ol>
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. A,2,3,8" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 4,5,6,Q" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 7,9,K" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. A,8,J" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ---------------------------------------------------
    // Utility Functions & Sequence‐Finding / Evaluation
    // ---------------------------------------------------

    // Map face‐card ranks to numeric values
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
    };

    // Extract rank portion (e.g. "10♠" → "10", "JOK" → null)
    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    // Extract suit portion (e.g. "10♠" → "♠")
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    // Card‐point value given the designated wild‐rank:
    //  • JOK = 0  
    //  • If rank == designatedWild → 0  
    //  • A,10,J,Q,K (if leftover) = 10  
    //  • 2–9 (if leftover) = face value
    function cardPointValue(card, designatedWild) {
      if (card === 'JOK') return 0;
      const rank = getRank(card);
      if (rank === designatedWild) return 0;
      if (['A','10','J','Q','K'].includes(rank)) return 10;
      return parseInt(rank, 10);
    }

    // ------- Find ALL Pure Sequences (length ≥ 3) -------
    // Returns an array of arrays, e.g. [ ['2♣','3♣','4♣'], ['7♥','8♥','9♥'], … ]
    function findAllPureSequences(cards) {
      const sequences = [];
      const suitOrder = ['♣','♦','♥','♠'];

      suitOrder.forEach(suit => {
        // Gather all NON‐JOK cards of this suit
        const suitCards = cards
          .filter(c => typeof c === 'string' && c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined)
          .sort((a, b) => a.num - b.num);

        const nums = suitCards.map(o => o.num);
        // Scan for consecutive runs:
        let i = 0;
        while (i < nums.length) {
          let run = [ suitCards[i] ];
          let prev = nums[i];
          let j = i + 1;
          while (j < nums.length && nums[j] === prev + 1) {
            run.push(suitCards[j]);
            prev = nums[j];
            j++;
          }
          if (run.length >= 3) {
            sequences.push(run.map(o => o.card));
            // Skip past this run (no overlap)
            i = j;
          } else {
            i++;
          }
        }
      });

      return sequences;
    }

    // ------- Find Optimal Impure Sequence (length ≥ 3) -------
    function findImpureSequence(cards, designatedRank) {
      // Count how many pure Jokers we have
      const pureJokers = cards.filter(c => c === 'JOK').length;
      // Collect all designated‐rank cards
      const designatedCards = cards.filter(c => typeof c === 'string' && getRank(c) === designatedRank);
      const wildcardCount = pureJokers + designatedCards.length;

      // Build list of "non‐wild, non‐JOK" cards
      const nonWildCards = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedRank);

      let best = {
        run: [],
        leftoverPoints: Infinity,
        runLength: 0
      };

      const suitOrder = ['♣','♦','♥','♠'];
      suitOrder.forEach(suit => {
        // Build rank→card map for this suit (excluding wild & JOK)
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (typeof c === 'string' && getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a,b) => a - b);

        const maxLen = ranks.length + wildcardCount;
        for (let windowSize = maxLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCards = [];
            let presentCount = 0;
            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              // We can form an impure run
              let usedJ = 0, usedD = 0;
              const runCards = presentCards.slice();
              for (let k = 0; k < missing; k++) {
                if (usedJ < pureJokers) {
                  runCards.push('JOK');
                  usedJ++;
                } else {
                  runCards.push(designatedCards[usedD]);
                  usedD++;
                }
              }

              // Compute leftover points if we remove runCards
              let temp = cards.slice();
              runCards.forEach(cd => {
                const idx = temp.indexOf(cd);
                if (idx !== -1) temp.splice(idx, 1);
              });

              const leftoverPts = temp.reduce((sum, c) =>
                sum + cardPointValue(c, designatedRank), 0
              );
              if (
                leftoverPts < best.leftoverPoints
                || (leftoverPts === best.leftoverPoints && runCards.length > best.runLength)
              ) {
                best = {
                  run: runCards,
                  leftoverPoints: leftoverPts,
                  runLength: runCards.length
                };
              }
            }
          }
        }
      });

      if (best.run.length < 3) return [];
      return best.run;
    }

    // ------- Full Evaluation: All Pure + All Impure Sequences -------
    function evaluateHand(cards, designatedRank) {
      // 1) Find all pure sequences
      const pureSequences = findAllPureSequences(cards);

      // 2) Remove every card in every pure sequence from a working copy
      let working = cards.slice();
      pureSequences.forEach(seq => {
        seq.forEach(card => {
          const idx = working.indexOf(card);
          if (idx !== -1) working.splice(idx, 1);
        });
      });

      // 3) Repeatedly find the optimal impure sequence (length ≥ 3)
      const impureSequences = [];
      while (true) {
        const nextImpure = findImpureSequence(working, designatedRank);
        if (nextImpure.length < 3) break;
        impureSequences.push(nextImpure);
        nextImpure.forEach(card => {
          const idx = working.indexOf(card);
          if (idx !== -1) working.splice(idx, 1);
        });
      }

      // 4) Now 'working' holds leftover cards; but remove any designated‐rank cards
      const leftoverRaw = working.slice();
      const leftover = leftoverRaw.filter(c => getRank(c) !== designatedRank);

      // 5) Compute points for leftover only
      let pts = leftover.reduce((sum, c) => sum + cardPointValue(c, designatedRank), 0);
      if (pts > 80) pts = 80;

      return {
        pureSequences: pureSequences,
        impureSequences: impureSequences,
        leftover: leftover,
        points: pts
      };
    }


    // ------------------------------------
    // DOM & Event Handling
    // ------------------------------------

    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = ''; // Clear previous

      // Helper: parse one suit’s text into ["<rank><suit>"]
      function parseSuit(text, suitSymbol) {
        if (!text.trim()) return [];
        return text
          .split(',')
          .map(s => s.trim().toUpperCase())
          .filter(x => x.length > 0)
          .map(x => x + suitSymbol);
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;   // e.g. "5" or ""
      const jokersRaw   = jokersInput.value.trim();

      // 2) Validate number of Jokers
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build full cards array
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Validate each card’s format
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const rank = getRank(c);
        const suit = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(rank) || !validSuits.includes(suit)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML =
          '<span class="error">Invalid card(s): ' +
          invalids.join(', ') +
          '.<br>Use ranks A,2–10,J,Q,K plus suit ♣,♦,♥,♠.</span>';
        return;
      }

      // 5) If no wildRank chosen, set to null
      const designatedRank = wildRank || null;

      // 6) Evaluate
      const evalResult = evaluateHand(cards, designatedRank);

      // 7) Build output
      let out = '';
      // Pure sequences:
      out += '<div class="section-title">All Pure Sequences (length ≥ 3):</div>';
      if (evalResult.pureSequences.length === 0) {
        out += '  None \n';
      } else {
        evalResult.pureSequences.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      // Impure sequences:
      out += '\n<div class="section-title">All Impure Sequences (length ≥ 3):</div>';
      if (evalResult.impureSequences.length === 0) {
        out += '  None \n';
      } else {
        evalResult.impureSequences.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      // Leftover cards:
      out += '\n<div class="section-title">Leftover Cards (counted as points):</div>';
      if (evalResult.leftover.length === 0) {
        out += '  None \n';
      } else {
        out += '  ' + evalResult.leftover.join(', ') + '\n';
      }

      // Total:
      out += '\n<div class="section-title">Total Points (capped at 80):</div>';
      out += '  ' + evalResult.points + '\n';

      resultDiv.innerHTML = out;
    });

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
