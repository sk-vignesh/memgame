<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Assistant (Impure Sets + Sequences)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
      white-space: pre-wrap;
    }
    .error {
      color: red;
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Rummy Assistant (Impure Sets + Sequences)</h1>
  <p>
    Enter exactly 13 cards total. For each suit (♣, ♦, ♥, ♠), type your ranks as a <strong>continuous string</strong> (no commas/spaces), using:
    <br>
    <strong>`A 2 3 4 5 6 7 8 9 T J Q K`</strong> 
    (where **T** = “10”).  
    Then choose your Wild‐card rank (or leave blank), and specify how many pure Jokers (JOK) you have (0–2).  
    <br><br>
    <strong>Important:</strong> To “win,” your final grouping must include at least one pure sequence and at least one impure sequence or impure set. Otherwise, no grouping counts—every non‐JOK, non‐wild card is counted toward your penalty.
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. A23T" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 456Q" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 7TK" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. AJ8" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ------------------------------
    // UTILITY & EVALUATION LOGIC
    // ------------------------------
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
    };

    // Convert input‐character to rank string
    function normalizeRankChar(ch) {
      if (ch === 'T') return '10';
      return ch;
    }

    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    function cardPointValue(card, designatedWild) {
      if (card === 'JOK') return 0;
      const r = getRank(card);
      if (r === designatedWild) return 0;
      if (['A','10','J','Q','K'].includes(r)) return 10;
      return parseInt(r, 10);
    }

    // 1) Find all pure sequences (length ≥ 3) in one suit.
    //    Exclude wild unless no normal‐only run ≥ 3; otherwise include wilds.
    function findPureSequencesForSuit(cards, suit, designatedWild) {
      // (A) Build “normal” list: same suit, not JOK, rank ≠ wild.
      const normalList = cards
        .filter(c => c !== 'JOK' && getSuit(c) === suit && getRank(c) !== designatedWild)
        .map(c => ({ card: c, num: rankMap[getRank(c)] }))
        .filter(o => o.num !== undefined)
        .sort((a, b) => a.num - b.num);

      const sequences = [];
      const nums = normalList.map(o => o.num);
      let i = 0;
      while (i < nums.length) {
        let run = [normalList[i]];
        let prev = nums[i];
        let j = i + 1;
        while (j < nums.length && nums[j] === prev + 1) {
          run.push(normalList[j]);
          prev = nums[j];
          j++;
        }
        if (run.length >= 3) {
          sequences.push(run.map(o => o.card));
          i = j;
        } else {
          i++;
        }
      }

      // (B) If no normal‐only run ≥ 3, include wilds to form sequences
      if (sequences.length === 0) {
        const allList = cards
          .filter(c => c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined)
          .sort((a, b) => a.num - b.num);

        const allNums = allList.map(o => o.num);
        let x = 0;
        while (x < allNums.length) {
          let run = [allList[x]];
          let prev = allNums[x];
          let y = x + 1;
          while (y < allNums.length && allNums[y] === prev + 1) {
            run.push(allList[y]);
            prev = allNums[y];
            y++;
          }
          if (run.length >= 3) {
            sequences.push(run.map(o => o.card));
            x = y;
          } else {
            x++;
          }
        }
      }

      return sequences; // array of [card,card,…]
    }

    function findAllPureSequences(cards, designatedWild) {
      const out = [];
      for (const s of ['♣','♦','♥','♠']) {
        const seqs = findPureSequencesForSuit(cards, s, designatedWild);
        out.push(...seqs);
      }
      return out;
    }

    // 2) Find all pure sets (3+ cards of same rank).
    function findAllPureSets(cards) {
      const buckets = {};
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        if (!buckets[r]) buckets[r] = [];
        buckets[r].push(c);
      });
      const sets = [];
      for (const r in buckets) {
        if (buckets[r].length >= 3) {
          sets.push(buckets[r].slice());
        }
      }
      return sets;
    }

    // 3) Find optimal impure sequence (length ≥ 3) to minimize leftover.
    function findImpureSequence(cards, designatedWild) {
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const designatedCards = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      const wildcardCount = pureJokers + designatedCards.length;
      const nonWildCards = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);

      let best = { run: [], leftoverPoints: Infinity, runLength: 0 };

      for (const suit of ['♣','♦','♥','♠']) {
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a, b) => a - b);
        const maxLen = ranks.length + wildcardCount;

        for (let windowSize = maxLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCards = [];
            let presentCount = 0;
            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              let usedJ = 0, usedD = 0;
              const runCards = presentCards.slice();
              for (let k = 0; k < missing; k++) {
                if (usedJ < pureJokers) {
                  runCards.push('JOK');
                  usedJ++;
                } else {
                  runCards.push(designatedCards[usedD]);
                  usedD++;
                }
              }

              let temp = cards.slice();
              runCards.forEach(cd => {
                const idx = temp.indexOf(cd);
                if (idx !== -1) temp.splice(idx, 1);
              });
              const leftoverPts = temp.reduce((sum, c) =>
                sum + cardPointValue(c, designatedWild), 0
              );
              if (
                leftoverPts < best.leftoverPoints ||
                (leftoverPts === best.leftoverPoints && runCards.length > best.runLength)
              ) {
                best = {
                  run: runCards,
                  leftoverPoints: leftoverPts,
                  runLength: runCards.length
                };
              }
            }
          }
        }
      }

      return best.run.length >= 3 ? best.run : [];
    }

    // Helper: remove one occurrence of each element in rem from src
    function arrayMinus(src, rem) {
      const out = src.slice();
      rem.forEach(el => {
        const idx = out.indexOf(el);
        if (idx !== -1) out.splice(idx, 1);
      });
      return out;
    }

    // 4) Recursively search for impure sets & sequences on “working” to minimize leftover.
    function searchImpureGroups(working, designatedWild) {
      // (A) Determine available wildcards:
      const jokersCount = working.filter(c => c === 'JOK').length;
      const wildcardsList = working.filter(c => getRank(c) === designatedWild);

      // 1) Build list of all possible impure sets:
      const sets = [];
      // For each rank r, see how many actual cards and if (#actual + #wildcards) ≥ 3
      const rankBuckets = {};
      working.forEach(c => {
        if (c === 'JOK' || getRank(c) === designatedWild) return;
        const r = getRank(c);
        if (!rankBuckets[r]) rankBuckets[r] = [];
        rankBuckets[r].push(c);
      });
      Object.keys(rankBuckets).forEach(r => {
        const actualCards = rankBuckets[r];
        const countActual = actualCards.length;
        const wildAvailable = jokersCount + wildcardsList.length;
        if (countActual + wildAvailable >= 3) {
          // We will form a set of exactly 3 cards to minimize wildcard use:
          const needed = 3 - countActual;
          // Take as many Jokers as possible, then wildcards
          const chosenWild = [];
          let jkUsed = Math.min(needed, jokersCount);
          for (let i = 0; i < jkUsed; i++) chosenWild.push('JOK');
          let wdUsed = needed - jkUsed;
          for (let i = 0; i < wdUsed; i++) chosenWild.push(wildcardsList[i]);
          sets.push(actualCards.concat(chosenWild));
        }
      });

      // 2) Find the single best impure sequence:
      const bestSeq = findImpureSequence(working, designatedWild);

      // 3) If no sets and no sequence, leftover is working minus wildcards, compute points
      if (sets.length === 0 && bestSeq.length < 3) {
        const leftover = working.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);
        let pts = leftover.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (pts > 80) pts = 80;
        return {
          impureSets: [],
          impureSeqs: [],
          leftover: leftover,
          points: pts
        };
      }

      let bestOutcome = null;

      // 4A) Try each impure set:
      sets.forEach(setGrp => {
        const rem = arrayMinus(working, setGrp);
        const sub = searchImpureGroups(rem, designatedWild);
        const candidate = {
          impureSets: [setGrp, ...sub.impureSets],
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // 4B) Try the best impure sequence (if length ≥ 3)
      if (bestSeq.length >= 3) {
        const remSeq = arrayMinus(working, bestSeq);
        const sub = searchImpureGroups(remSeq, designatedWild);
        const candidate = {
          impureSets: sub.impureSets.slice(),
          impureSeqs: [bestSeq, ...sub.impureSeqs],
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      }

      return bestOutcome;
    }

    // 5) Full evaluation: pure stage (as before), then impure stage using above.
    function searchPureGroups(working, designatedWild, rootHasPure, hasPickedPure) {
      const pureSeqs = findAllPureSequences(working, designatedWild);
      const pureSets = findAllPureSets(working);

      // If no pure sequences or sets, go to impure:
      if (pureSeqs.length === 0 && pureSets.length === 0) {
        const imp = searchImpureGroups(working, designatedWild);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }

      let bestOutcome = null;

      // (A) Try each pure sequence:
      pureSeqs.forEach(seq => {
        const rem = arrayMinus(working, seq);
        const sub = searchPureGroups(rem, designatedWild, rootHasPure, true);
        const candidate = {
          pureSeqs: [seq, ...sub.pureSeqs],
          pureSets: sub.pureSets.slice(),
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B) Try each pure set:
      pureSets.forEach(setGrp => {
        const rem = arrayMinus(working, setGrp);
        const sub = searchPureGroups(rem, designatedWild, rootHasPure, hasPickedPure);
        const candidate = {
          pureSeqs: sub.pureSeqs.slice(),
          pureSets: [setGrp, ...sub.pureSets],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (C) Skip pure → impure, but only if no pure sequence existed at root OR we've already picked one
      if (!rootHasPure || hasPickedPure) {
        const imp = searchImpureGroups(working, designatedWild);
        const candidate = {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      }

      return bestOutcome;
    }

    // 6) Main evaluate: determine if any pure sequence at root, then recurse.
    function evaluateHand(cards, designatedWild) {
      const rootPureList = findAllPureSequences(cards, designatedWild);
      const rootHasPure = (rootPureList.length > 0);
      return searchPureGroups(cards, designatedWild, rootHasPure, false);
    }

    // 7) Override if no pure sequence OR no impure group
    function finalResult(cards, designatedWild) {
      const res = evaluateHand(cards, designatedWild);
      if (res.pureSeqs.length < 1 || (res.impureSets.length + res.impureSeqs.length) < 1) {
        // No valid grouping → count all non-JOK, non-wild
        const leftoverAll = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);
        let pts = leftoverAll.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (pts > 80) pts = 80;
        return {
          pureSeqs: [], pureSets: [], impureSets: [], impureSeqs: [],
          leftover: leftoverAll,
          points: pts
        };
      }
      return res;
    }

    // ---------------------------------------
    // DOM & EVENT HANDLING
    // ---------------------------------------
    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = '';

      // Convert input‐string into [ "<rank><suit>" ]
      function parseSuit(inputText, suitSymbol) {
        const chars = inputText.trim().toUpperCase().split('');
        const cards = [];
        chars.forEach(ch => {
          const norm = normalizeRankChar(ch);
          const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
          if (validRanks.includes(norm)) {
            cards.push(norm + suitSymbol);
          }
        });
        return cards;
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;   // "" or "7","10", etc.
      const jokersRaw   = jokersInput.value.trim();

      // 2) Validate Jokers count
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build card array
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Enforce exactly 13 cards
      if (cards.length !== 13) {
        resultDiv.innerHTML = '<span class="error">Error: You must enter exactly 13 cards total (suits + Jokers). Currently you have ' 
                              + cards.length + '.</span>';
        return;
      }

      // 5) Validate each card
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        const s = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(r) || !validSuits.includes(s)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML =
          '<span class="error">Invalid card(s): ' + invalids.join(', ') +
          '.<br>Use ranks A,2–9,T,J,Q,K plus suits ♣,♦,♥,♠.</span>';
        return;
      }

      // 6) Determine designatedWild (or null)
      const designatedWild = wildRank || null;

      // 7) Compute final result
      const res = finalResult(cards, designatedWild);

      // 8) Build and display output
      let out = '';
      out += '<div class="section-title">All Pure Sequences (length ≥ 3):</div>';
      if (res.pureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.pureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Pure Sets (length ≥ 3):</div>';
      if (res.pureSets.length === 0) {
        out += '  None \n';
      } else {
        res.pureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sets (length ≥ 3, using wild/JOK):</div>';
      if (res.impureSets.length === 0) {
        out += '  None \n';
      } else {
        res.impureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sequences (length ≥ 3):</div>';
      if (res.impureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.impureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">Leftover Cards (counted as points):</div>';
      if (res.leftover.length === 0) {
        out += '  None \n';
      } else {
        out += '  ' + res.leftover.join(', ') + '\n';
      }

      out += '\n<div class="section-title">Total Points (capped at 80):</div>';
      out += '  ' + res.points + '\n';

      resultDiv.innerHTML = out;
    }); 

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
