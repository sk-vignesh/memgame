<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Assistant (Exhaustive Impure Sequences)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
      white-space: pre-wrap;
    }
    .error {
      color: red;
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Rummy Assistant (Exhaustive Impure Sequences)</h1>
  <p>
    Enter exactly 13 cards total. For each suit (♣, ♦, ♥, ♠), type your ranks as a <strong>continuous string</strong> (no commas/spaces), using:
    <br>
    <strong>`A 2 3 4 5 6 7 8 9 T J Q K`</strong> 
    (where **T** = “10”). Then choose your Wild‐card rank (or leave blank), and specify how many pure Jokers (JOK) you have (0–2).  
    <br><br>
    <strong>Rule:</strong> You must form at least two sequences (pure or impure). Once two sequences are formed, the assistant focuses on minimizing leftover points—choosing any impure set or any impure sequence that reduces points most.  
    Unlike before, this version will enumerate <em>all</em> possible impure sequences of length ≥ 3 at each step, so you will never end up with a suboptimal single long impure run when two smaller impure sets would yield fewer leftover points.
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. 89T3" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 57" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 35689" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. 35" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ----------------------------
    // UTILITY & EVALUATION LOGIC
    // ----------------------------
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
    };

    // Convert rank-character to rank string ("T" → "10")
    function normalizeRankChar(ch) {
      if (ch === 'T') return '10';
      return ch;
    }

    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    // Point value: JOK = 0, wild = 0, A/10/J/Q/K = 10, others face value
    function cardPointValue(card, designatedWild) {
      if (card === 'JOK') return 0;
      const r = getRank(card);
      if (r === designatedWild) return 0;
      if (['A','10','J','Q','K'].includes(r)) return 10;
      return parseInt(r, 10);
    }

    // 1) Find pure sequences (length ≥ 3) in a given suit.
    //    Pass 1 (Normal‐only): exclude JOK & rank = designatedWild.
    //    Pass 2 (Fallback): exclude only JOK, include wild‐rank in same‐suit runs.
    function findPureSequencesForSuit(cards, suit, designatedWild) {
      // Pass 1: “Normal-only” run
      const normalList = cards
        .filter(c => c !== 'JOK' && getSuit(c) === suit && getRank(c) !== designatedWild)
        .map(c => ({ card: c, num: rankMap[getRank(c)] }))
        .filter(o => o.num !== undefined)
        .sort((a, b) => a.num - b.num);

      const sequences = [];
      const nums = normalList.map(o => o.num);
      let i = 0;
      while (i < nums.length) {
        let run = [normalList[i]];
        let prev = nums[i];
        let j = i + 1;
        while (j < nums.length && nums[j] === prev + 1) {
          run.push(normalList[j]);
          prev = nums[j];
          j++;
        }
        if (run.length >= 3) {
          sequences.push(run.map(o => o.card));
          i = j;
        } else {
          i++;
        }
      }

      // Pass 2: Fallback (only if Pass 1 found nothing)
      if (sequences.length === 0) {
        const allList = cards
          .filter(c => c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined)
          .sort((a, b) => a.num - b.num);

        const allNums = allList.map(o => o.num);
        let x = 0;
        while (x < allNums.length) {
          let run = [allList[x]];
          let prev = allNums[x];
          let y = x + 1;
          while (y < allNums.length && allNums[y] === prev + 1) {
            run.push(allList[y]);
            prev = allNums[y];
            y++;
          }
          if (run.length >= 3) {
            sequences.push(run.map(o => o.card));
            x = y;
          } else {
            x++;
          }
        }
      }

      return sequences; // array of [card, …]
    }

    function findAllPureSequences(cards, designatedWild) {
      const out = [];
      for (const s of ['♣','♦','♥','♠']) {
        const seqs = findPureSequencesForSuit(cards, s, designatedWild);
        out.push(...seqs);
      }
      return out;
    }

    // 2) Find all pure sets (≥ 3 cards of the same rank).
    function findAllPureSets(cards) {
      const buckets = {};
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        if (!buckets[r]) buckets[r] = [];
        buckets[r].push(c);
      });
      const sets = [];
      for (const r in buckets) {
        if (buckets[r].length >= 3) {
          sets.push(buckets[r].slice());
        }
      }
      return sets;
    }

    // 3) Enumerate _all_ impure sequences (length ≥ 3) in all suits:
    //    (A) Count how many JOK and how many designatedWild cards in `cards`.
    //    (B) For each suit, for each possible windowSize ≥ 3, for each start=1..(14-windowSize):
    //        see if (# missing) ≤ (jokers + wildcards). Whenever it works, record the exact run.
    function findAllImpureSequences(cards, designatedWild) {
      const impureSeqs = [];
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const designatedCards = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      const wildcardCount = pureJokers + designatedCards.length;
      const nonWildCards = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);

      for (const suit of ['♣','♦','♥','♠']) {
        // Build a map: rankNumber → cardString
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a, b) => a - b);
        const maxLen = ranks.length + wildcardCount;

        // Try every possible window size down from maxLen to 3
        for (let windowSize = maxLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCards = [];
            let presentCount = 0;
            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              // We can form a run of length = windowSize by filling with JOK first, then wildcards
              let usedJ = 0, usedD = 0;
              const runCards = presentCards.slice();
              for (let k = 0; k < missing; k++) {
                if (usedJ < pureJokers) {
                  runCards.push('JOK');
                  usedJ++;
                } else {
                  runCards.push(designatedCards[usedD]);
                  usedD++;
                }
              }
              // Sort runCards by (suit=all same) then numeric rank
              runCards.sort((a, b) => {
                if (a === 'JOK') return 1;
                if (b === 'JOK') return -1;
                const na = rankMap[getRank(a)], nb = rankMap[getRank(b)];
                return na - nb;
              });
              // Record this run (avoid duplicates by JSON‐string check)
              const key = JSON.stringify(runCards);
              if (!impureSeqs.some(existing => JSON.stringify(existing) === key)) {
                impureSeqs.push(runCards);
              }
            }
          }
        }
      }
      return impureSeqs; // array of arrays of card‐strings
    }

    // 4) Find all impure sets (length = 3 exactly) in `cards`.
    //    A set = 3 cards of same rank, using as many real‐rank cards as possible,
    //    then filling with Jokers, then designatedWild if still needed.
    function findAllImpureSets(cards, designatedWild) {
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const wildcardsList = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      const rankBuckets = {};
      cards.forEach(c => {
        if (c === 'JOK' || getRank(c) === designatedWild) return;
        const r = getRank(c);
        if (!rankBuckets[r]) rankBuckets[r] = [];
        rankBuckets[r].push(c);
      });
      const sets = [];
      Object.keys(rankBuckets).forEach(r => {
        const actualCards = rankBuckets[r];
        const countActual = actualCards.length;
        const wildAvailable = pureJokers + wildcardsList.length;
        if (countActual + wildAvailable >= 3) {
          // Form a set of exactly 3
          const needed = 3 - countActual;
          const chosenWild = [];
          let jkUsed = Math.min(needed, pureJokers);
          for (let i = 0; i < jkUsed; i++) chosenWild.push('JOK');
          let wdUsed = needed - jkUsed;
          for (let i = 0; i < wdUsed; i++) chosenWild.push(wildcardsList[i]);
          const setGrp = actualCards.concat(chosenWild);
          sets.push(setGrp);
        }
      });
      return sets; // array of [card,card,card]
    }

    // Helper: remove one occurrence of each element in `rem` from `src`
    function arrayMinus(src, rem) {
      const out = src.slice();
      rem.forEach(el => {
        const idx = out.indexOf(el);
        if (idx !== -1) out.splice(idx, 1);
      });
      return out;
    }

    // 5) Recursively search impure groups:
    //    If sequencesFormedCount < 2, force at least one impure sequence if possible.
    //    Once sequencesFormedCount ≥ 2, enumerate all possible impure sequences and all possible impure sets,
    //    recurse over each, and choose the branch that yields minimal leftover points.
    function searchImpureGroups(working, designatedWild, sequencesFormedCount) {
      // (A) If fewer than 2 sequences formed so far, try any impure sequence first
      if (sequencesFormedCount < 2) {
        const allSeqs = findAllImpureSequences(working, designatedWild);
        if (allSeqs.length > 0) {
          let bestBranch = null;
          allSeqs.forEach(seq => {
            const remSeq = arrayMinus(working, seq);
            const sub = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
            const branch = {
              impureSets: sub.impureSets.slice(),
              impureSeqs: [seq, ...sub.impureSeqs],
              leftover: sub.leftover.slice(),
              points: sub.points
            };
            if (!bestBranch || branch.points < bestBranch.points) {
              bestBranch = branch;
            }
          });
          return bestBranch;
        }
        // If no impure sequence exists, fall through to try sets (still < 2).
      }

      // (B) sequencesFormedCount ≥ 2 OR no sequence when < 2: now we consider BOTH sets & sequences.
      // Build three kinds of candidates:
      //   1) Take each impure sequence (length ≥ 3) and recurse;
      //   2) Take each impure set (exactly 3 cards of same rank) and recurse;
      //   3) If neither available, treat all non-JOK cards as leftover.

      // Candidate list
      let bestOutcome = null;

      // (B1) Try every impure sequence
      const allSeqs2 = findAllImpureSequences(working, designatedWild);
      allSeqs2.forEach(seq => {
        const remSeq = arrayMinus(working, seq);
        const subSeq = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
        const candidate = {
          impureSets: subSeq.impureSets.slice(),
          impureSeqs: [seq, ...subSeq.impureSeqs],
          leftover: subSeq.leftover.slice(),
          points: subSeq.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B2) Try every impure set (exactly 3 cards)
      const allSets = findAllImpureSets(working, designatedWild);
      allSets.forEach(setGrp => {
        const remSet = arrayMinus(working, setGrp);
        const subSet = searchImpureGroups(remSet, designatedWild, sequencesFormedCount);
        const candidate = {
          impureSets: [setGrp, ...subSet.impureSets],
          impureSeqs: subSet.impureSeqs.slice(),
          leftover: subSet.leftover.slice(),
          points: subSet.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B3) If no sets/sequences possible, everything (except JOK) is leftover
      if (bestOutcome === null) {
        const leftoverOnly = working.filter(c => c !== 'JOK');
        let ptsOnly = leftoverOnly.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (ptsOnly > 80) ptsOnly = 80;
        bestOutcome = {
          impureSets: [],
          impureSeqs: [],
          leftover: leftoverOnly,
          points: ptsOnly
        };
      }

      return bestOutcome;
    }

    // 6) Recursively search pure groups; once no more pure groups, hand off to impure with sequence count = (# pure sequences used so far)
    function searchPureGroups(working, designatedWild) {
      const pureSeqs = findAllPureSequences(working, designatedWild);
      const pureSets = findAllPureSets(working);

      // If no pure groups possible at all, go immediately to impure with count = 0
      if (pureSeqs.length === 0 && pureSets.length === 0) {
        const imp = searchImpureGroups(working, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }

      let bestOutcome = null;

      // (A) Try each pure sequence (counts as 1 sequence formed)
      pureSeqs.forEach(seq => {
        const rem = arrayMinus(working, seq);
        const sub = searchImpureGroups(rem, designatedWild, 1);
        const candidate = {
          pureSeqs: [seq],
          pureSets: [],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B) Try each pure set (does NOT increase sequence count)
      pureSets.forEach(setGrp => {
        const rem = arrayMinus(working, setGrp);
        const sub = searchPureGroups(rem, designatedWild);
        const candidate = {
          pureSeqs: sub.pureSeqs.slice(),
          pureSets: [setGrp, ...sub.pureSets],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (C) Skip pure entirely → go to impure with count = 0
      {
        const imp = searchImpureGroups(working, designatedWild, 0);
        const candidate = {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      }

      return bestOutcome;
    }

    // 7) Main evaluate: if no pure sequences at all, go impure with count=0; otherwise recurse
    function evaluateHand(cards, designatedWild) {
      const allPureSeqs = findAllPureSequences(cards, designatedWild);
      if (allPureSeqs.length === 0) {
        const imp = searchImpureGroups(cards, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }
      return searchPureGroups(cards, designatedWild);
    }

    // 8) If fewer than two total sequences (pure + impure), count all non‐JOK as leftover
    function finalResult(cards, designatedWild) {
      const res = evaluateHand(cards, designatedWild);
      const totalSequences = res.pureSeqs.length + res.impureSeqs.length;
      if (totalSequences < 2) {
        const leftoverAll = cards.filter(c => c !== 'JOK');
        let pts = leftoverAll.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (pts > 80) pts = 80;
        return {
          pureSeqs: [], pureSets: [], impureSets: [], impureSeqs: [],
          leftover: leftoverAll,
          points: pts
        };
      }
      return res;
    }

    // ----------------------------
    // DOM & EVENT HANDLING
    // ----------------------------
    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = '';

      // Parse a continuous string (e.g. "89T3") into [ "<rank><suit>" ]
      function parseSuit(inputText, suitSymbol) {
        const chars = inputText.trim().toUpperCase().split('');
        const cards = [];
        chars.forEach(ch => {
          const norm = normalizeRankChar(ch);
          const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
          if (validRanks.includes(norm)) {
            cards.push(norm + suitSymbol);
          }
        });
        return cards;
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;   // "" or e.g. "J"
      const jokersRaw   = jokersInput.value.trim();

      // 2) Validate Jokers count
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build card array (suits + JOK)
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Enforce exactly 13 cards
      if (cards.length !== 13) {
        resultDiv.innerHTML = '<span class="error">Error: You must enter exactly 13 cards total (suits + Jokers). Currently you have ' 
                              + cards.length + '.</span>';
        return;
      }

      // 5) Validate each card’s format
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        const s = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(r) || !validSuits.includes(s)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML =
          '<span class="error">Invalid card(s): ' + invalids.join(', ') +
          '.<br>Use ranks A,2–9,T,J,Q,K plus suits ♣,♦,♥,♠.</span>';
        return;
      }

      // 6) Set designatedWild (or null)
      const designatedWild = wildRank || null;

      // 7) Compute final grouping & leftover
      const res = finalResult(cards, designatedWild);

      // 8) Build and display output
      let out = '';
      out += '<div class="section-title">All Pure Sequences (length ≥ 3):</div>';
      if (res.pureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.pureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Pure Sets (length ≥ 3):</div>';
      if (res.pureSets.length === 0) {
        out += '  None \n';
      } else {
        res.pureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sets (length ≥ 3, using wild/JOK):</div>';
      if (res.impureSets.length === 0) {
        out += '  None \n';
      } else {
        res.impureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sequences (length ≥ 3):</div>';
      if (res.impureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.impureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">Leftover Cards (counted as points):</div>';
      if (res.leftover.length === 0) {
        out += '  None \n';
      } else {
        out += '  ' + res.leftover.join(', ') + '\n';
      }

      out += '\n<div class="section-title">Total Points (capped at 80):</div>';
      out += '  ' + res.points + '\n';

      resultDiv.innerHTML = out;
    });

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
