<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rummy Assistant (Up to Two Sequences, Fixed Leftover Wild)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 10px;
    }
    .input-group > div {
      flex: 1 1 200px;
      display: flex;
      flex-direction: column;
    }
    label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select {
      padding: 6px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="number"] {
      width: 70px;
    }
    button {
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 10px;
    }
    #result {
      margin-top: 20px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
      white-space: pre-wrap;
    }
    .error {
      color: red;
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Rummy Assistant (Up to Two Sequences, Fixed Leftover Wild)</h1>
  <p>
    Enter exactly 13 cards total. For each suit (♣, ♦, ♥, ♠), type your ranks as a <strong>continuous string</strong> (no commas/spaces), using:
    <br>
    <strong>`A 2 3 4 5 6 7 8 9 T J Q K`</strong> 
    (where **T** = “10”).  
    Then choose your Wild‐card rank (or leave blank), and specify how many pure Jokers (JOK) you have (0–2).  
    <br><br>
    <strong>Rule:</strong> You must form at least two sequences total (pure or impure). Once two sequences are formed, the system then focuses on minimizing leftover points—choosing either impure sets or sequences that reduce points the most.
  </p>

  <div class="input-group">
    <div>
      <label for="clubsInput">Clubs (♣):</label>
      <input type="text" id="clubsInput" placeholder="e.g. A23T" />
    </div>
    <div>
      <label for="diamondsInput">Diamonds (♦):</label>
      <input type="text" id="diamondsInput" placeholder="e.g. 456QJ" />
    </div>
    <div>
      <label for="heartsInput">Hearts (♥):</label>
      <input type="text" id="heartsInput" placeholder="e.g. 7TK" />
    </div>
    <div>
      <label for="spadesInput">Spades (♠):</label>
      <input type="text" id="spadesInput" placeholder="e.g. AJ8" />
    </div>
    <div>
      <label for="wildRankSelect">Wild Card Rank:</label>
      <select id="wildRankSelect">
        <option value="">(None)</option>
        <option value="A">A</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="J">J</option>
        <option value="Q">Q</option>
        <option value="K">K</option>
      </select>
    </div>
    <div style="flex: 0 0 100px;">
      <label for="jokersInput">Jokers:</label>
      <input type="number" id="jokersInput" min="0" max="2" value="0" />
    </div>
  </div>

  <button id="evaluateBtn">Evaluate</button>
  <button id="clearBtn">Clear</button>

  <div id="result"></div>

  <script>
    // ------------------------------
    // UTILITY & EVALUATION LOGIC
    // ------------------------------
    const rankMap = {
      'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
    };

    // Convert input‐character to rank string
    function normalizeRankChar(ch) {
      if (ch === 'T') return '10';
      return ch;
    }

    function getRank(card) {
      if (card === 'JOK') return null;
      return card.slice(0, -1);
    }
    function getSuit(card) {
      if (card === 'JOK') return null;
      return card.slice(-1);
    }

    function cardPointValue(card, designatedWild) {
      if (card === 'JOK') return 0;
      const r = getRank(card);
      if (r === designatedWild) return 0;
      if (['A','10','J','Q','K'].includes(r)) return 10;
      return parseInt(r, 10);
    }

    // 1) Find pure sequences (length ≥ 3) in one suit
    //    Exclude wild unless no normal‐only run ≥ 3; else include wilds
    function findPureSequencesForSuit(cards, suit, designatedWild) {
      // (A) Build “normal” list: same suit, not JOK, rank ≠ wild
      const normalList = cards
        .filter(c => c !== 'JOK' && getSuit(c) === suit && getRank(c) !== designatedWild)
        .map(c => ({ card: c, num: rankMap[getRank(c)] }))
        .filter(o => o.num !== undefined)
        .sort((a, b) => a.num - b.num);

      const sequences = [];
      const nums = normalList.map(o => o.num);
      let i = 0;
      while (i < nums.length) {
        let run = [normalList[i]];
        let prev = nums[i];
        let j = i + 1;
        while (j < nums.length && nums[j] === prev + 1) {
          run.push(normalList[j]);
          prev = nums[j];
          j++;
        }
        if (run.length >= 3) {
          sequences.push(run.map(o => o.card));
          i = j;
        } else {
          i++;
        }
      }

      // (B) If no normal‐only run ≥ 3, include wilds to form any run ≥ 3
      if (sequences.length === 0) {
        const allList = cards
          .filter(c => c !== 'JOK' && getSuit(c) === suit)
          .map(c => ({ card: c, num: rankMap[getRank(c)] }))
          .filter(o => o.num !== undefined)
          .sort((a, b) => a.num - b.num);

        const allNums = allList.map(o => o.num);
        let x = 0;
        while (x < allNums.length) {
          let run = [allList[x]];
          let prev = allNums[x];
          let y = x + 1;
          while (y < allNums.length && allNums[y] === prev + 1) {
            run.push(allList[y]);
            prev = allNums[y];
            y++;
          }
          if (run.length >= 3) {
            sequences.push(run.map(o => o.card));
            x = y;
          } else {
            x++;
          }
        }
      }

      return sequences; // array of [card,...]
    }

    function findAllPureSequences(cards, designatedWild) {
      const out = [];
      for (const s of ['♣','♦','♥','♠']) {
        const seqs = findPureSequencesForSuit(cards, s, designatedWild);
        out.push(...seqs);
      }
      return out;
    }

    // 2) Find pure sets (3+ cards of same rank)
    function findAllPureSets(cards) {
      const buckets = {};
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        if (!buckets[r]) buckets[r] = [];
        buckets[r].push(c);
      });
      const sets = [];
      for (const r in buckets) {
        if (buckets[r].length >= 3) {
          sets.push(buckets[r].slice());
        }
      }
      return sets;
    }

    // 3) Find optimal impure sequence (length ≥ 3) to minimize leftover
    function findImpureSequence(cards, designatedWild) {
      const pureJokers = cards.filter(c => c === 'JOK').length;
      const designatedCards = cards.filter(c => c !== 'JOK' && getRank(c) === designatedWild);
      const wildcardCount = pureJokers + designatedCards.length;
      const nonWildCards = cards.filter(c => c !== 'JOK' && getRank(c) !== designatedWild);

      let best = { run: [], leftoverPoints: Infinity, runLength: 0 };

      for (const suit of ['♣','♦','♥','♠']) {
        const suitMap = {};
        nonWildCards.forEach(c => {
          if (getSuit(c) === suit) {
            const num = rankMap[getRank(c)];
            if (num !== undefined) suitMap[num] = c;
          }
        });
        const ranks = Object.keys(suitMap).map(n => parseInt(n)).sort((a, b) => a - b);
        const maxLen = ranks.length + wildcardCount;

        for (let windowSize = maxLen; windowSize >= 3; windowSize--) {
          for (let start = 1; start <= 14 - windowSize; start++) {
            const end = start + windowSize - 1;
            let presentCards = [];
            let presentCount = 0;
            for (let r = start; r <= end; r++) {
              if (suitMap[r]) {
                presentCount++;
                presentCards.push(suitMap[r]);
              }
            }
            const missing = windowSize - presentCount;
            if (missing <= wildcardCount) {
              let usedJ = 0, usedD = 0;
              const runCards = presentCards.slice();
              for (let k = 0; k < missing; k++) {
                if (usedJ < pureJokers) {
                  runCards.push('JOK');
                  usedJ++;
                } else {
                  runCards.push(designatedCards[usedD]);
                  usedD++;
                }
              }

              let temp = cards.slice();
              runCards.forEach(cd => {
                const idx = temp.indexOf(cd);
                if (idx !== -1) temp.splice(idx, 1);
              });
              const leftoverPts = temp.reduce((sum, c) =>
                sum + cardPointValue(c, designatedWild), 0
              );
              if (
                leftoverPts < best.leftoverPoints ||
                (leftoverPts === best.leftoverPoints && runCards.length > best.runLength)
              ) {
                best = {
                  run: runCards,
                  leftoverPoints: leftoverPts,
                  runLength: runCards.length
                };
              }
            }
          }
        }
      }

      return best.run.length >= 3 ? best.run : [];
    }

    // Helper: remove one occurrence of each element in rem from src
    function arrayMinus(src, rem) {
      const out = src.slice();
      rem.forEach(el => {
        const idx = out.indexOf(el);
        if (idx !== -1) out.splice(idx, 1);
      });
      return out;
    }

    // 4) Search impure groups; if fewer than 2 sequences formed, force sequence first;
    //    once 2 sequences are formed, choose whichever (set or sequence) reduces leftover most.
    function searchImpureGroups(working, designatedWild, sequencesFormedCount) {
      // (A) If we still need to form sequences (fewer than 2 so far), try impure sequence first:
      if (sequencesFormedCount < 2) {
        const run = findImpureSequence(working, designatedWild);
        if (run.length >= 3) {
          // Form that impure sequence, increment count, recurse
          const remSeq = arrayMinus(working, run);
          const sub = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
          return {
            impureSets: sub.impureSets.slice(),
            impureSeqs: [run, ...sub.impureSeqs],
            leftover: sub.leftover.slice(),
            points: sub.points
          };
        }
        // If no impure sequence exists, fall through to consider impure sets
      }

      // (B) Now either sequencesFormedCount ≥ 2 OR (no sequence found when < 2). 
      //     We generate both candidate branches (impure sequence & impure set & leftover-only) and choose the best.

      // (B1) Candidate A: Remove best impure sequence (if exists)
      let bestSequenceBranch = null;
      const bestSeq = findImpureSequence(working, designatedWild);
      if (bestSeq.length >= 3) {
        const remSeq = arrayMinus(working, bestSeq);
        const subSeq = searchImpureGroups(remSeq, designatedWild, sequencesFormedCount + 1);
        bestSequenceBranch = {
          impureSets: subSeq.impureSets.slice(),
          impureSeqs: [bestSeq, ...subSeq.impureSeqs],
          leftover: subSeq.leftover.slice(),
          points: subSeq.points
        };
      }

      // (B2) Candidate B: Form any impure set (choose the one that leads to minimal leftover)
      const jokersCount = working.filter(c => c === 'JOK').length;
      const wildcardsList = working.filter(c => getRank(c) === designatedWild);

      const sets = [];
      const rankBuckets = {};
      working.forEach(c => {
        if (c === 'JOK' || getRank(c) === designatedWild) return;
        const r = getRank(c);
        if (!rankBuckets[r]) rankBuckets[r] = [];
        rankBuckets[r].push(c);
      });
      Object.keys(rankBuckets).forEach(r => {
        const actualCards = rankBuckets[r];
        const countActual = actualCards.length;
        const wildAvailable = jokersCount + wildcardsList.length;
        if (countActual + wildAvailable >= 3) {
          // Form a 3-card set using all actual plus minimal wilds
          const needed = 3 - countActual;
          const chosenWild = [];
          let jkUsed = Math.min(needed, jokersCount);
          for (let i = 0; i < jkUsed; i++) chosenWild.push('JOK');
          let wdUsed = needed - jkUsed;
          for (let i = 0; i < wdUsed; i++) chosenWild.push(wildcardsList[i]);
          sets.push(actualCards.concat(chosenWild));
        }
      });

      let bestSetBranch = null;
      sets.forEach(setGrp => {
        const remSet = arrayMinus(working, setGrp);
        const subSet = searchImpureGroups(remSet, designatedWild, sequencesFormedCount);
        const candidate = {
          impureSets: [setGrp, ...subSet.impureSets],
          impureSeqs: subSet.impureSeqs.slice(),
          leftover: subSet.leftover.slice(),
          points: subSet.points
        };
        if (!bestSetBranch || candidate.points < bestSetBranch.points) {
          bestSetBranch = candidate;
        }
      });

      // (B3) Candidate C: No more impure grouping → leftover only
      const leftoverOnly = working.filter(c => c !== 'JOK');
      let ptsOnly = leftoverOnly.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
      if (ptsOnly > 80) ptsOnly = 80;
      const leftoverBranch = {
        impureSets: [],
        impureSeqs: [],
        leftover: leftoverOnly,
        points: ptsOnly
      };

      // Compare among A, B, and C
      let bestOutcome = leftoverBranch;
      if (bestSequenceBranch && bestSequenceBranch.points < bestOutcome.points) {
        bestOutcome = bestSequenceBranch;
      }
      if (bestSetBranch && bestSetBranch.points < bestOutcome.points) {
        bestOutcome = bestSetBranch;
      }
      return bestOutcome;
    }

    // 5) Search pure groups; then call impure with sequencesFormedCount = number of pure sequences chosen
    function searchPureGroups(working, designatedWild) {
      const pureSeqs = findAllPureSequences(working, designatedWild);
      const pureSets = findAllPureSets(working);

      // If no pure grouping possible, jump immediately to impure with count = 0
      if (pureSeqs.length === 0 && pureSets.length === 0) {
        const imp = searchImpureGroups(working, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }

      let bestOutcome = null;

      // (A) Try each pure sequence
      pureSeqs.forEach(seq => {
        const rem = arrayMinus(working, seq);
        // Forming this pure sequence counts as 1 sequence
        const sub = searchImpureGroups(rem, designatedWild, 1);
        const candidate = {
          pureSeqs: [seq, ...sub.pureSeqs],
          pureSets: sub.pureSets ? sub.pureSets.slice() : [],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (B) Try each pure set (does not increase sequence count)
      pureSets.forEach(setGrp => {
        const rem = arrayMinus(working, setGrp);
        const sub = searchPureGroups(rem, designatedWild);
        const candidate = {
          pureSeqs: sub.pureSeqs.slice(),
          pureSets: [setGrp, ...sub.pureSets],
          impureSets: sub.impureSets.slice(),
          impureSeqs: sub.impureSeqs.slice(),
          leftover: sub.leftover.slice(),
          points: sub.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      });

      // (C) Skip pure entirely → go to impure with count = 0
      {
        const imp = searchImpureGroups(working, designatedWild, 0);
        const candidate = {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
        if (!bestOutcome || candidate.points < bestOutcome.points) {
          bestOutcome = candidate;
        }
      }

      return bestOutcome;
    }

    // 6) Main evaluate: if no pure sequences at all, go impure with count=0; else recurse
    function evaluateHand(cards, designatedWild) {
      const allPureSeqs = findAllPureSequences(cards, designatedWild);
      if (allPureSeqs.length === 0) {
        const imp = searchImpureGroups(cards, designatedWild, 0);
        return {
          pureSeqs: [],
          pureSets: [],
          impureSets: imp.impureSets,
          impureSeqs: imp.impureSeqs,
          leftover: imp.leftover,
          points: imp.points
        };
      }
      return searchPureGroups(cards, designatedWild);
    }

    // 7) Override if fewer than two sequences total
    function finalResult(cards, designatedWild) {
      const res = evaluateHand(cards, designatedWild);
      const totalSequences = res.pureSeqs.length + res.impureSeqs.length;
      if (totalSequences < 2) {
        const leftoverAll = cards.filter(c => c !== 'JOK');
        let pts = leftoverAll.reduce((sum, c) => sum + cardPointValue(c, designatedWild), 0);
        if (pts > 80) pts = 80;
        return {
          pureSeqs: [], pureSets: [], impureSets: [], impureSeqs: [],
          leftover: leftoverAll,
          points: pts
        };
      }
      return res;
    }

    // ---------------------------------------
    // DOM & EVENT HANDLING
    // ---------------------------------------
    const clubsInput     = document.getElementById('clubsInput');
    const diamondsInput  = document.getElementById('diamondsInput');
    const heartsInput    = document.getElementById('heartsInput');
    const spadesInput    = document.getElementById('spadesInput');
    const wildRankSelect = document.getElementById('wildRankSelect');
    const jokersInput    = document.getElementById('jokersInput');
    const evaluateBtn    = document.getElementById('evaluateBtn');
    const clearBtn       = document.getElementById('clearBtn');
    const resultDiv      = document.getElementById('result');

    evaluateBtn.addEventListener('click', () => {
      resultDiv.innerHTML = '';

      // Convert input‐string into [ "<rank><suit>" ]
      function parseSuit(inputText, suitSymbol) {
        const chars = inputText.trim().toUpperCase().split('');
        const cards = [];
        chars.forEach(ch => {
          const norm = normalizeRankChar(ch);
          const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
          if (validRanks.includes(norm)) {
            cards.push(norm + suitSymbol);
          }
        });
        return cards;
      }

      // 1) Read inputs
      const clubsRaw    = clubsInput.value;
      const diamondsRaw = diamondsInput.value;
      const heartsRaw   = heartsInput.value;
      const spadesRaw   = spadesInput.value;
      const wildRank    = wildRankSelect.value;   // "" or "7","10", etc.
      const jokersRaw   = jokersInput.value.trim();

      // 2) Validate Jokers count
      const jokersCount = parseInt(jokersRaw, 10);
      if (isNaN(jokersCount) || jokersCount < 0 || jokersCount > 2) {
        resultDiv.innerHTML = '<span class="error">“Jokers” must be 0, 1, or 2.</span>';
        return;
      }

      // 3) Build card array
      let cards = [];
      cards = cards.concat(
        parseSuit(clubsRaw, '♣'),
        parseSuit(diamondsRaw, '♦'),
        parseSuit(heartsRaw, '♥'),
        parseSuit(spadesRaw, '♠')
      );
      for (let i = 0; i < jokersCount; i++) {
        cards.push('JOK');
      }

      // 4) Enforce exactly 13 cards
      if (cards.length !== 13) {
        resultDiv.innerHTML = '<span class="error">Error: You must enter exactly 13 cards total (suits + Jokers). Currently you have ' 
                              + cards.length + '.</span>';
        return;
      }

      // 5) Validate each card
      const invalids = [];
      cards.forEach(c => {
        if (c === 'JOK') return;
        const r = getRank(c);
        const s = getSuit(c);
        const validRanks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const validSuits = ['♣','♦','♥','♠'];
        if (!validRanks.includes(r) || !validSuits.includes(s)) {
          invalids.push(c);
        }
      });
      if (invalids.length) {
        resultDiv.innerHTML =
          '<span class="error">Invalid card(s): ' + invalids.join(', ') +
          '.<br>Use ranks A,2–9,T,J,Q,K plus suits ♣,♦,♥,♠.</span>';
        return;
      }

      // 6) Determine designatedWild (or null)
      const designatedWild = wildRank || null;

      // 7) Compute final result
      const res = finalResult(cards, designatedWild);

      // 8) Build and display output
      let out = '';
      out += '<div class="section-title">All Pure Sequences (length ≥ 3):</div>';
      if (res.pureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.pureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Pure Sets (length ≥ 3):</div>';
      if (res.pureSets.length === 0) {
        out += '  None \n';
      } else {
        res.pureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sets (length ≥ 3, using wild/JOK):</div>';
      if (res.impureSets.length === 0) {
        out += '  None \n';
      } else {
        res.impureSets.forEach(setGrp => {
          out += '  • ' + setGrp.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">All Impure Sequences (length ≥ 3):</div>';
      if (res.impureSeqs.length === 0) {
        out += '  None \n';
      } else {
        res.impureSeqs.forEach(seq => {
          out += '  • ' + seq.join(', ') + '\n';
        });
      }

      out += '\n<div class="section-title">Leftover Cards (counted as points):</div>';
      if (res.leftover.length === 0) {
        out += '  None \n';
      } else {
        out += '  ' + res.leftover.join(', ') + '\n';
      }

      out += '\n<div class="section-title">Total Points (capped at 80):</div>';
      out += '  ' + res.points + '\n';

      resultDiv.innerHTML = out;
    });

    clearBtn.addEventListener('click', () => {
      clubsInput.value    = '';
      diamondsInput.value = '';
      heartsInput.value   = '';
      spadesInput.value   = '';
      wildRankSelect.value= '';
      jokersInput.value   = '0';
      resultDiv.innerHTML = '';
    });
  </script>
</body>
</html>
